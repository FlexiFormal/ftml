use ftml_uris::{SymbolUri, UriName};

use crate::expressions::Variable;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ExprKind {
    Symbol(u32),
    Var(u32),
    Application(u8),
    Bound,
    Field,
    Label,
    Opaque,
}
syntree::flavor! {
    struct FlavorEmpty {
        type Index = syntree::Empty;
        type Indexes = syntree::EmptyVec<syntree::TreeIndex<Self>>;
    }
}

struct SynExprTree {
    symbols: Vec<SymbolUri>,
    variables: Vec<Variable>,
    keys: Vec<UriName>,
    tree: syntree::Tree<ExprKind, FlavorEmpty>,
}
impl SynExprTree {
    pub fn as_node(&self) -> SynExprNode<'_> {
        // SAFETY: non-empty by construction
        SynExprNode(self, unsafe { self.tree.first().unwrap_unchecked() })
    }
}

struct SynExprNode<'a>(&'a SynExprTree, syntree::Node<'a, ExprKind, FlavorEmpty>);
impl<'a> SynExprNode<'a> {
    pub fn symbol(&self) -> Option<&'a SymbolUri> {
        if let ExprKind::Symbol(u) = self.1.value() {
            self.0.symbols.get(u as usize)
        } else {
            None
        }
    }
    pub fn application(&self) -> Option<()> {
        let ExprKind::Application(len) = self.1.value() else {
            return None;
        };
        let mut ch = self.1.children();
        // SAFETY:non-empty by construction
        let head = unsafe { ch.next().unwrap_unchecked() };
    }
}
